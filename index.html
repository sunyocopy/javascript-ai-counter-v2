<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/x-icon" href="image/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, user-scalable=yes">
  
  <title>AI Counter - F11 v2 (Final)</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Prompt:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <style>
    body { font-family: "Prompt", sans-serif; }
    #canvas-container { position: relative; width: 100%; border-radius: 0.75rem; overflow: hidden; background-color: #1e293b; }
    #canvas-container canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; touch-action: manipulation; }
    
    /* แก้ไขปัญหา @apply ด้วย Standard CSS */
    .control-btn {
      width: 2.25rem; height: 2.25rem; display: flex; align-items: center; justify-content: center;
      background-color: white; border-radius: 0.5rem; color: #4f46e5; font-weight: bold;
      border: 1px solid #e2e8f0; transition: all 0.1s; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .control-btn:hover { background-color: #f8fafc; }
    .control-btn:active { transform: scale(0.9); }
  </style>
</head>
<body class="bg-slate-50 py-4 px-3">
  
  <div class="w-full max-w-4xl mx-auto bg-white rounded-3xl shadow-2xl overflow-hidden border border-slate-200">
    <div class="bg-indigo-600 p-4 text-white flex justify-between items-center">
      <h2 class="text-xl font-bold uppercase tracking-wider flex items-center gap-2">
        <span class="material-icons">analytics</span> AI Counter F11_v2
      </h2>
      <div id="status" class="flex items-center gap-1 text-xs bg-indigo-500 px-3 py-1 rounded-full border border-indigo-400">
        <span class="material-icons text-sm animate-spin" id="status-icon">hourglass_empty</span>
        <span id="status-text">Loading Model...</span>
      </div>
    </div>

    <div class="p-4 space-y-4">
      <div id="total-count-display" class="hidden flex flex-col items-center py-4 bg-indigo-50 rounded-2xl border-2 border-indigo-100">
        <span class="text-gray-500 text-xs font-medium tracking-widest uppercase">ตรวจพบเหล็กทั้งหมด</span>
        <div class="text-7xl font-black text-indigo-700 leading-tight" id="count-number">0</div>
        <span class="text-indigo-400 text-xs font-bold uppercase">Pieces Detected</span>
      </div>

      <div class="flex flex-wrap gap-3 justify-center items-center bg-slate-50 p-3 rounded-2xl border border-slate-100">
        
        <div class="flex items-center bg-white rounded-xl px-2 py-1 border border-slate-200 shadow-sm">
          <div class="flex flex-col items-start pr-2 border-r border-slate-100 mr-2">
            <span class="text-[9px] font-bold text-slate-400 uppercase leading-none">Confidence</span>
            <span class="text-[10px] text-indigo-500 font-bold">ความแม่นยำ</span>
          </div>
          <button id="conf-down" class="control-btn">-</button>
          <div id="conf-value" class="w-12 text-center font-black text-indigo-700">0.45</div>
          <button id="conf-up" class="control-btn">+</button>
        </div>

        <div class="flex items-center bg-white rounded-xl px-2 py-1 border border-slate-200 shadow-sm">
          <div class="flex flex-col items-start pr-2 border-r border-slate-100 mr-2">
            <span class="text-[9px] font-bold text-slate-400 uppercase leading-none">Overlap</span>
            <span class="text-[10px] text-pink-500 font-bold">ลดการซ้อน</span>
          </div>
          <button id="iou-down" class="control-btn">-</button>
          <div id="iou-value" class="w-12 text-center font-black text-pink-600">0.45</div>
          <button id="iou-up" class="control-btn">+</button>
        </div>

        <input type="file" id="image-input" accept="image/*" class="text-xs text-slate-500 file:mr-3 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-indigo-600 file:text-white file:font-semibold hover:file:bg-indigo-700 cursor-pointer">
      </div>

      <div class="flex flex-wrap gap-2 justify-center">
        <button id="select-area-btn" class="flex items-center gap-2 px-6 py-3 bg-white border-2 border-slate-200 text-slate-700 font-bold rounded-xl transition-all shadow-sm active:scale-95">
          <span class="material-icons text-pink-500" id="btn-icon">brush</span> <span id="btn-text">เลือกพื้นที่</span>
        </button>

        <button id="reset-btn" class="flex items-center gap-2 px-6 py-3 bg-white border-2 border-red-100 text-red-600 font-bold rounded-xl hover:bg-red-50">
          <span class="material-icons">refresh</span> <span>ล้างพื้นที่</span>
        </button>

        <button id="download-btn" class="hidden items-center gap-2 px-8 py-3 bg-slate-900 text-white font-bold rounded-xl shadow-lg hover:bg-slate-800 active:scale-95 transition-all">
          <span class="material-icons text-green-400">download</span> <span>บันทึกรูป</span>
        </button>
      </div>

      <div id="canvas-container">
        <canvas id="canvas" style="z-index: 1;"></canvas>
        <canvas id="drawing-canvas" style="z-index: 2; cursor: crosshair;"></canvas>
      </div>
    </div>
  </div>

  <script>
    const imageInput = document.getElementById("image-input");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const drawingCanvas = document.getElementById("drawing-canvas");
    const drawingCtx = drawingCanvas.getContext("2d");
    
    const statusText = document.getElementById("status-text");
    const statusDiv = document.getElementById("status");
    const statusIcon = document.getElementById("status-icon");
    const countNumber = document.getElementById("count-number");
    const countDisplay = document.getElementById("total-count-display");
    const selectAreaBtn = document.getElementById("select-area-btn");
    const btnText = document.getElementById("btn-text");
    const confValueDisplay = document.getElementById("conf-value");
    const iouValueDisplay = document.getElementById("iou-value");
    
    let session;
    let currentImage;
    let drawnPath = null;
    let isInSelectionMode = false;
    let isDrawing = false;

    // Default Values
    let confThreshold = 0.45;
    let iouThreshold = 0.45;

    async function loadModel() {
      try {
        session = await ort.InferenceSession.create("./f11_yolo11n_v2.onnx"); 
        statusText.innerText = "READY (Model F11)"; 
        statusDiv.className = "flex items-center gap-1 text-xs bg-green-500 px-3 py-1 rounded-full border border-green-400 text-white";
        statusIcon.innerText = "check_circle"; 
        statusIcon.classList.remove("animate-spin");
      } catch (e) { 
        statusText.innerText = "MODEL ERROR"; 
        Swal.fire({ icon: 'error', title: 'ไม่พบไฟล์โมเดล', text: 'ตรวจสอบไฟล์ f11_yolo11n_v2.onnx' });
      }
    }
    loadModel();

    // UI Adjustment Logic
    function updateThresholds() {
      confValueDisplay.innerText = confThreshold.toFixed(2);
      iouValueDisplay.innerText = iouThreshold.toFixed(2);
      if (currentImage) runInference(currentImage);
    }

    document.getElementById("conf-up").onclick = () => { if(confThreshold < 0.95) { confThreshold += 0.05; updateThresholds(); }};
    document.getElementById("conf-down").onclick = () => { if(confThreshold > 0.05) { confThreshold -= 0.05; updateThresholds(); }};
    document.getElementById("iou-up").onclick = () => { if(iouThreshold < 0.95) { iouThreshold += 0.05; updateThresholds(); }};
    document.getElementById("iou-down").onclick = () => { if(iouThreshold > 0.05) { iouThreshold -= 0.05; updateThresholds(); }};

    imageInput.addEventListener("change", (e) => {
      const file = e.target.files[0]; if (!file) return;
      drawnPath = null; 
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      isInSelectionMode = false;
      resetButtonUI();

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image(); img.src = event.target.result;
        img.onload = () => {
          currentImage = img;
          document.getElementById("canvas-container").style.paddingTop = `${(img.height / img.width) * 100}%`;
          canvas.width = drawingCanvas.width = img.width; 
          canvas.height = drawingCanvas.height = img.height;
          ctx.drawImage(img, 0, 0); 
          runInference(img);
          document.getElementById("download-btn").classList.replace("hidden", "flex");
        };
      };
      reader.readAsDataURL(file);
    });

    async function runInference(image) {
      if (!session) return;
      const size = 640;
      const scale = Math.min(size / image.width, size / image.height);
      const dx = (size - image.width * scale) / 2;
      const dy = (size - image.height * scale) / 2;

      const temp = document.createElement("canvas"); temp.width = temp.height = size;
      const tCtx = temp.getContext("2d"); 
      tCtx.fillStyle = "#808080"; tCtx.fillRect(0, 0, size, size);
      tCtx.drawImage(image, dx, dy, image.width * scale, image.height * scale);
      
      const imgData = tCtx.getImageData(0, 0, size, size);
      const floatData = new Float32Array(3 * size * size);
      for (let i = 0; i < imgData.data.length; i += 4) { 
        floatData[i/4] = imgData.data[i]/255.0;            
        floatData[i/4 + 409600] = imgData.data[i+1]/255.0; 
        floatData[i/4 + 819200] = imgData.data[i+2]/255.0; 
      }
      
      const res = await session.run({ images: new ort.Tensor("float32", floatData, [1, 3, size, size]) });
      processAndDraw(Object.values(res)[0], image, scale, dx, dy);
    }

    function nms(boxes, threshold) {
      if (boxes.length === 0) return [];
      boxes.sort((a, b) => b[4] - a[4]); const result = [];
      while (boxes.length > 0) {
        const current = boxes.shift(); result.push(current);
        boxes = boxes.filter(box => {
          const x1 = Math.max(current[0], box[0]), y1 = Math.max(current[1], box[1]), x2 = Math.min(current[2], box[2]), y2 = Math.min(current[3], box[3]);
          const w = Math.max(0, x2 - x1), h = Math.max(0, y2 - y1);
          const iou = (w * h) / ((current[2]-current[0])*(current[3]-current[1]) + (box[2]-box[0])*(box[3]-box[1]) - (w * h));
          return iou < threshold;
        });
      }
      return result;
    }

    function processAndDraw(output, image, scale, dx, dy) {
      let boxes = [];
      for (let i = 0; i < output.dims[2]; i++) {
        const score = output.data[4 * output.dims[2] + i];
        if (score > confThreshold) { 
          const x = output.data[i], y = output.data[i + output.dims[2]], w = output.data[i + 2 * output.dims[2]], h = output.data[i + 3 * output.dims[2]];
          boxes.push([x - w/2, y - h/2, x + w/2, y + h/2, score]);
        }
      }
      
      let finalBoxes = nms(boxes, iouThreshold);
      finalBoxes.sort((a, b) => ((a[1] + a[3]) / 2) - ((b[1] + b[3]) / 2));
      
      ctx.drawImage(image, 0, 0); 
      let count = 0;
      finalBoxes.forEach((box) => {
        const cx = ((box[0] + box[2]) / 2 - dx) / scale;
        const cy = ((box[1] + box[3]) / 2 - dy) / scale;
        const r = (Math.max(box[2] - box[0], box[3] - box[1]) / 2 / scale) * 0.7;

        if (cx >= 0 && cx <= image.width && cy >= 0 && cy <= image.height) {
          if (!drawnPath || drawingCtx.isPointInPath(drawnPath, cx, cy)) {
            count++; 
            ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); 
            ctx.strokeStyle = "#22c55e"; ctx.lineWidth = Math.max(2, image.width * 0.002); ctx.stroke();
            ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(cx, cy, r * 0.75, 0, 2 * Math.PI); ctx.fill();
            ctx.fillStyle = "black"; ctx.font = `bold ${Math.round(r)}px Prompt`; 
            ctx.textAlign = "center"; ctx.textBaseline = "middle"; 
            ctx.fillText(count, cx, cy);
          }
        }
      });
      countNumber.innerText = count; countDisplay.classList.remove("hidden");
    }

    // Drawing Logic
    function getCoords(e) {
      const rect = drawingCanvas.getBoundingClientRect();
      const scaleX = drawingCanvas.width / rect.width;
      const scaleY = drawingCanvas.height / rect.height;
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } 
      else { clientX = e.clientX; clientY = e.clientY; }
      return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    function startDrawing(e) {
      if (!isInSelectionMode) return;
      isDrawing = true; drawnPath = new Path2D();
      const {x, y} = getCoords(e); drawnPath.moveTo(x, y);
    }
    function draw(e) {
      if (!isDrawing || !isInSelectionMode) return;
      const {x, y} = getCoords(e); drawnPath.lineTo(x, y);
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      drawingCtx.strokeStyle = "#ec4899";
      drawingCtx.lineWidth = Math.max(4, drawingCanvas.width * 0.004);
      drawingCtx.lineCap = "round"; drawingCtx.lineJoin = "round"; drawingCtx.stroke(drawnPath);
    }
    function stopDrawing() {
      if (isDrawing) {
        isDrawing = false; drawnPath.closePath();
        drawingCtx.fillStyle = "rgba(236, 72, 153, 0.2)"; drawingCtx.fill(drawnPath);
        runInference(currentImage);
      }
    }

    drawingCanvas.addEventListener("mousedown", startDrawing);
    window.addEventListener("mousemove", draw);
    window.addEventListener("mouseup", stopDrawing);
    drawingCanvas.addEventListener("touchstart", startDrawing, { passive: false });
    window.addEventListener("touchmove", draw, { passive: false });
    window.addEventListener("touchend", stopDrawing);

    function resetButtonUI() {
      selectAreaBtn.className = "flex items-center gap-2 px-6 py-3 bg-white border-2 border-slate-200 text-slate-700 font-bold rounded-xl shadow-sm";
      btnText.innerText = "เลือกพื้นที่";
    }
    selectAreaBtn.onclick = () => {
      if(!currentImage) return; isInSelectionMode = !isInSelectionMode;
      if (isInSelectionMode) {
        selectAreaBtn.className = "flex items-center gap-2 px-6 py-3 bg-pink-600 text-white font-bold rounded-xl shadow-lg transform scale-105";
        btnText.innerText = "วาดได้เลย";
      } else {
        resetButtonUI(); drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); runInference(currentImage);
      }
    };
    document.getElementById("reset-btn").onclick = () => {
      if(!currentImage) return; drawnPath = null; isInSelectionMode = false;
      resetButtonUI(); drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); runInference(currentImage);
    };
    document.getElementById("download-btn").onclick = () => {
      const link = document.createElement("a");
      link.download = `RebarCount-${countNumber.innerText}.png`;
      link.href = canvas.toDataURL(); link.click();
    };
  </script>
</body>
</html>